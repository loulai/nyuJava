import java.util.Scanner;



public class AssignmentMain {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		System.out.println("hello");
		
		stringInputToTree(input.nextLine());
		
//		while(input.hasNext("[^()]*")){
//			System.out.println(input.next());
//		}
		
//		if (input.hasNext("[^(]")){
//			System.out.println("whoooo");
//			System.out.println(input.next());
//		}
		
//		while(input.hasNext()){
//			System.out.println("==inif");
//			System.out.printf("Element: %s, Distance: %.1f\n", input.next(), input.nextDouble());
//		}
	}
	
	public Double findClosest(TreeNode<Double> root, Object target) throws BinaryHeap.UnderflowException {
	    	BinaryHeap<TreeNode<Double>> minheap = new BinaryHeap<TreeNode<Double>>();
	    	minheap.insert(root);
	    	TreeNode<Double> t;
	  
	    	while(!minheap.isEmpty()){
	    		
	    		t = minheap.deleteMin();
	    		
	    		if(t != null && !t.element.equals(target)){
	    			if(t.left!=null){
	    				t.left.distance += t.distance;
	    				minheap.insert(t.left);
	    			}
	    			if(t.right!=null){
	    				t.right.distance += t.distance;
	    				minheap.insert(t.right);
	    			}
	    		return t.distance;
		    	} //this if loop ends if the element is not found. If the element was found, with min value, then it would've been returned
	    	}
	    	return -1.0;
	  }
	
	public static void stringInputToTree(String stringInput) {
		 ArrayStack<TreeNode> stack = new ArrayStack<TreeNode>();
		 Scanner tokenizer = new Scanner(stringInput);
		 while(tokenizer.hasNext()){
			 if(tokenizer.hasNext("[^()]")){ //if is is anything other than "(" or ")"
				 TreeNode<String> treeNode = new TreeNode<String>(tokenizer.next(), tokenizer.nextDouble());
				 System.out.println("Pushing in : " + treeNode);
				 stack.push(treeNode);
			 } else if (tokenizer.hasNext("[(]")){
				 System.out.println("(");
				 tokenizer.next();
			 } else {
				 System.out.println(")");
				 TreeNode rightChild = stack.top();
				 System.out.println("Popping: " + rightChild);
				 stack.pop();
				 
				 TreeNode leftChild = stack.top();
				 System.out.println("Popping: " + leftChild);
				 stack.pop();
				 
				 stack.top().setRightChild(rightChild);
				 stack.top().setLeftChild(leftChild);
				 System.out.println("parent: " + stack.top());
			 }
		 }
	}

}
